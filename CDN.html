<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CDN 工作原理演示</title>
    <!-- 引入 Tailwind CSS CDN，用于快速造型 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Google Fonts - Inter 字体，提升可读性 -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* 全局样式设置，使用 Inter 字体和浅色背景 */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* 浅蓝灰色背景 */
            color: #333;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        /* 主容器样式，居中显示，带有圆角和阴影 */
        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: #fff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            /* 响应式调整边距 */
            @media (max-width: 768px) {
                margin: 1rem;
                padding: 1rem;
            }
        }
        /* 动画区域样式，相对定位，用于放置可动元素 */
        .animation-area {
            position: relative;
            min-height: 500px;
            background-color: #e2e8f0; /* 更浅的蓝灰色作为动画背景 */
            border-radius: 0.75rem;
            overflow: hidden; /* 隐藏超出边界的线条/圆点 */
            /* 响应式调整高度 */
            @media (max-width: 768px) {
                min-height: 350px;
            }
        }
        /* 动画元素（用户、服务器、CDN节点）的通用样式 */
        .element {
            position: absolute;
            background-color: #4f46e5; /* 靛蓝色 */
            color: #fff;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            font-weight: 600;
            text-align: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.5s ease-in-out; /* 平滑过渡效果 */
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap; /* 防止文字换行 */
            /* 响应式调整字体大小和填充 */
            @media (max-width: 768px) {
                font-size: 0.875rem; /* text-sm */
                padding: 0.5rem 0.8rem;
            }
        }
        /* 各个元素的特定位置和颜色 */
        .element.user { top: 70%; left: 5%; background-color: #10b981; } /* 用户 (绿色) */
        .element.origin { top: 10%; left: 45%; background-color: #ef4444; } /* 原始服务器 (红色) */
        .element.cdn-node-1 { top: 40%; left: 20%; background-color: #f97316; } /* CDN节点 A (橙色) */
        .element.cdn-node-2 { top: 40%; left: 70%; background-color: #06b6d4; } /* CDN节点 B (青色) */
        .element.cdn-node-3 { top: 70%; left: 80%; background-color: #a855f7; } /* CDN节点 C (紫色) */

        /* 连接线的样式 */
        .line {
            position: absolute;
            border-top: 2px dashed #94a3b8; /* 石板灰色虚线 */
            transform-origin: 0 0; /* 旋转中心点 */
            display: none; /* 默认隐藏 */
            opacity: 0; /* 默认透明 */
            transition: opacity 0.5s ease-in-out; /* 透明度过渡 */
        }
        /* 动画圆点样式，代表数据流 */
        .dot {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #4f46e5; /* 靛蓝色 */
            border-radius: 50%; /* 圆形 */
            display: none; /* 默认隐藏 */
            opacity: 0; /* 默认透明 */
        }

        /* 关键帧动画，用于圆点沿路径移动 */
        @keyframes moveDot {
            from { transform: translate(0, 0); } /* 从起点开始 */
            to { transform: translate(var(--travel-x), var(--travel-y)); } /* 移动到指定偏移量 */
        }

        /* 用于显示元素的辅助类 */
        .fade-in {
            opacity: 1 !important;
            display: block !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center mb-6 text-gray-800">内容分发网络（CDN）工作原理动画演示</h1>

        <div id="animationArea" class="animation-area mb-8 p-4">
            <!-- 动画元素：用户、原始服务器和CDN节点 -->
            <div id="user" class="element user z-10">用户 (您)</div>
            <div id="origin" class="element origin z-10">原始服务器</div>
            <div id="cdn1" class="element cdn-node-1 z-10 hidden">CDN节点 A</div>
            <div id="cdn2" class="element cdn-node-2 z-10 hidden">CDN节点 B</div>
            <div id="cdn3" class="element cdn-node-3 z-10 hidden">CDN节点 C</div>

            <!-- 数据流的线条和圆点，使用 z-index 控制层级 -->
            <div id="line-user-origin" class="line z-[1]"></div>
            <div id="dot-user-origin" class="dot z-[2]"></div>

            <div id="line-origin-cdn1" class="line z-[1]"></div>
            <div id="dot-origin-cdn1" class="dot z-[2]"></div>
            <div id="line-cdn1-user" class="line z-[1]"></div>
            <div id="dot-cdn1-user" class="dot z-[2]"></div>

            <div id="line-user-cdn1-request" class="line z-[1]"></div>
            <div id="dot-user-cdn1-request" class="dot z-[2]"></div>
        </div>

        <!-- 步骤描述区域 -->
        <div id="description" class="bg-blue-100 text-blue-800 p-4 rounded-lg mb-6 shadow-inner text-lg">
            <p>欢迎来到CDN工作原理演示！点击“下一步”开始。</p>
        </div>

        <!-- 控制按钮区域 -->
        <div class="flex flex-wrap justify-center gap-4">
            <button id="nextBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 transform hover:scale-105">
                下一步
            </button>
            <button id="resetBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 transform hover:scale-105">
                重置
            </button>
            <button id="autoPlayBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 transform hover:scale-105">
                自动播放
            </button>
            <button id="pauseAutoPlayBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 transform hover:scale-105 hidden">
                暂停自动播放
            </button>
        </div>
    </div>

    <script>
        // 获取动画所需的HTML元素
        const userEl = document.getElementById('user');
        const originEl = document.getElementById('origin');
        const cdn1El = document.getElementById('cdn1');
        const cdn2El = document.getElementById('cdn2');
        const cdn3El = document.getElementById('cdn3');

        const animationArea = document.getElementById('animationArea');
        const descriptionEl = document.getElementById('description');
        const nextBtn = document.getElementById('nextBtn');
        const resetBtn = document.getElementById('resetBtn');
        const autoPlayBtn = document.getElementById('autoPlayBtn');
        const pauseAutoPlayBtn = document.getElementById('pauseAutoPlayBtn');

        let currentStep = 0; // 当前动画步骤索引
        let autoPlayInterval = null; // 自动播放的计时器ID
        let animationTimeout = null; // 单个动画（如圆点移动）的计时器ID

        /**
         * 获取元素相对于动画区域的位置（中心点）
         * @param {HTMLElement} el - HTML元素
         * @returns {{x: number, y: number}} - 元素的中心点坐标
         */
        function getElementPos(el) {
            const rect = el.getBoundingClientRect();
            const containerRect = animationArea.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2 - containerRect.left,
                y: rect.top + rect.height / 2 - containerRect.top
            };
        }

        /**
         * 绘制静态线条，连接两个元素
         * @param {HTMLElement} lineEl - 线条元素
         * @param {HTMLElement} startEl - 起始元素
         * @param {HTMLElement} endEl - 结束元素
         */
        function drawLinePath(lineEl, startEl, endEl) {
            const start = getElementPos(startEl);
            const end = getElementPos(endEl);

            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            lineEl.style.width = `${length}px`;
            lineEl.style.left = `${start.x}px`;
            lineEl.style.top = `${start.y}px`;
            lineEl.style.transform = `rotate(${angle}deg)`;
        }

        /**
         * 动画圆点沿线条移动
         * @param {HTMLElement} dotEl - 圆点元素
         * @param {HTMLElement} startEl - 起始元素
         * @param {HTMLElement} endEl - 结束元素
         * @param {number} duration - 动画持续时间（秒）
         * @param {function} callback - 动画完成后的回调函数
         * @returns {Promise<void>} - 返回一个Promise，动画完成后resolve
         */
        function animateDot(dotEl, startEl, endEl, duration = 1.5, callback = () => {}) {
            return new Promise(resolve => {
                const start = getElementPos(startEl);
                const end = getElementPos(endEl);

                const dx = end.x - start.x;
                const dy = end.y - start.y;

                dotEl.style.left = `${start.x}px`;
                dotEl.style.top = `${start.y}px`;
                dotEl.style.opacity = '1';
                dotEl.style.display = 'block';
                dotEl.style.animation = 'none'; // 清除之前的动画

                // 强制浏览器重排，以确保动画从头开始
                void dotEl.offsetWidth;

                // 设置CSS变量，供 @keyframes moveDot 使用
                dotEl.style.setProperty('--travel-x', `${dx}px`);
                dotEl.style.setProperty('--travel-y', `${dy}px`);
                dotEl.style.animation = `moveDot ${duration}s linear forwards`;

                // 动画完成后隐藏圆点，并执行回调和resolve Promise
                animationTimeout = setTimeout(() => {
                    dotEl.style.display = 'none';
                    dotEl.style.opacity = '0';
                    dotEl.style.animation = 'none';
                    callback();
                    resolve();
                }, duration * 1000);
            });
        }

        /**
         * 隐藏所有线条和圆点，并清除所有动画
         */
        function hideAllLinesAndDots() {
            document.querySelectorAll('.line').forEach(el => {
                el.style.display = 'none';
                el.style.opacity = '0';
            });
            document.querySelectorAll('.dot').forEach(el => {
                el.style.display = 'none';
                el.style.opacity = '0';
                el.style.animation = 'none'; // 停止所有圆点动画
            });
            // 确保清除可能存在的单个动画计时器
            if (animationTimeout) {
                clearTimeout(animationTimeout);
                animationTimeout = null;
            }
        }

        // 动画步骤定义
        const steps = [
            {
                description: "欢迎来到CDN工作原理演示！内容分发网络（CDN）旨在加速互联网内容的交付。点击“下一步”开始。",
                action: () => {
                    // 初始化状态：只显示用户和原始服务器
                    hideAllLinesAndDots();
                    userEl.classList.remove('hidden');
                    originEl.classList.remove('hidden');
                    cdn1El.classList.add('hidden');
                    cdn2El.classList.add('hidden');
                    cdn3El.classList.add('hidden');
                    return Promise.resolve(); // 返回一个已解决的Promise
                }
            },
            {
                description: "<b>第一步：没有CDN (传统访问)</b><br>用户直接从遥远的“原始服务器”请求内容。数据传输路径长，加载速度慢。",
                action: async () => {
                    hideAllLinesAndDots();
                    const lineEl = document.getElementById('line-user-origin');
                    lineEl.style.display = 'block';
                    lineEl.style.opacity = '1';
                    drawLinePath(lineEl, userEl, originEl); // 绘制静态连接线
                    await animateDot(document.getElementById('dot-user-origin'), userEl, originEl, 3); // 动画圆点沿线移动
                }
            },
            {
                description: "<b>第二步：引入CDN</b><br>CDN在全球各地部署了大量服务器节点（缓存服务器），它们会缓存网站内容，让用户可以从更近的地点获取数据。",
                action: () => {
                    hideAllLinesAndDots();
                    cdn1El.classList.remove('hidden');
                    cdn2El.classList.remove('hidden');
                    cdn3El.classList.remove('hidden');
                    // CDN节点短暂放大，表示出现/激活
                    [cdn1El, cdn2El, cdn3El].forEach(el => {
                        el.style.transform = 'scale(1.1)';
                        setTimeout(() => el.style.transform = 'scale(1)', 300);
                    });
                    return Promise.resolve();
                }
            },
            {
                description: "<b>第三步：有CDN (首次请求)</b><br>用户请求内容，请求首先被导向离用户最近的CDN节点（此处为CDN节点A）。如果CDN节点没有缓存内容，它会先从原始服务器获取，然后缓存并发送给用户。",
                action: async () => {
                    hideAllLinesAndDots();

                    // 1. 用户向最近的CDN节点发送请求
                    const userCdnLineReq = document.getElementById('line-user-cdn1-request');
                    userCdnLineReq.style.display = 'block';
                    userCdnLineReq.style.opacity = '1';
                    drawLinePath(userCdnLineReq, userEl, cdn1El);
                    await animateDot(document.getElementById('dot-user-cdn1-request'), userEl, cdn1El, 1.5);
                    hideAllLinesAndDots(); // 清除当前圆点动画

                    // 2. CDN节点从原始服务器获取内容
                    const cdnOriginLine = document.getElementById('line-origin-cdn1');
                    cdnOriginLine.style.display = 'block';
                    cdnOriginLine.style.opacity = '1';
                    drawLinePath(cdnOriginLine, cdn1El, originEl); // 从CDN到原始服务器
                    cdn1El.style.backgroundColor = '#facc15'; // 改变CDN节点颜色表示正在获取
                    await animateDot(document.getElementById('dot-origin-cdn1'), cdn1El, originEl, 2);
                    cdn1El.style.backgroundColor = '#f97316'; // 恢复CDN节点颜色
                    hideAllLinesAndDots(); // 清除当前圆点动画

                    // 3. CDN节点将内容发送给用户（并缓存）
                    const cdnUserLine = document.getElementById('line-cdn1-user');
                    cdnUserLine.style.display = 'block';
                    cdnUserLine.style.opacity = '1';
                    drawLinePath(cdnUserLine, cdn1El, userEl);
                    await animateDot(document.getElementById('dot-cdn1-user'), cdn1El, userEl, 1.5);
                }
            },
            {
                description: "<b>第四步：有CDN (后续请求)</b><br>当同一用户或附近的其他用户再次请求相同内容时，CDN节点会直接从其缓存中提供，无需再访问原始服务器，速度极快！",
                action: async () => {
                    hideAllLinesAndDots();

                    // 1. 用户向最近的CDN节点发送请求
                    const userCdnLineReq = document.getElementById('line-user-cdn1-request');
                    userCdnLineReq.style.display = 'block';
                    userCdnLineReq.style.opacity = '1';
                    drawLinePath(userCdnLineReq, userEl, cdn1El);
                    await animateDot(document.getElementById('dot-user-cdn1-request'), userEl, cdn1El, 1.5);
                    hideAllLinesAndDots(); // 清除当前圆点动画

                    // 2. CDN节点直接从缓存提供内容（无需访问原始服务器）
                    cdn1El.style.transform = 'scale(1.1)'; // CDN节点短暂放大表示从缓存提供
                    await new Promise(resolve => setTimeout(() => {
                        cdn1El.style.transform = 'scale(1)';
                        resolve();
                    }, 500));

                    // 3. CDN节点将内容发送给用户
                    const cdnUserLine = document.getElementById('line-cdn1-user');
                    cdnUserLine.style.display = 'block';
                    cdnUserLine.style.opacity = '1';
                    drawLinePath(cdnUserLine, cdn1El, userEl);
                    await animateDot(document.getElementById('dot-cdn1-user'), cdn1El, userEl, 1.5);
                }
            },
            {
                description: "<b>总结：CDN的优势</b><br>CDN极大地缩短了用户获取内容的距离，提高了网站加载速度，减轻了原始服务器的压力，提升了用户体验和系统稳定性。",
                action: () => {
                    hideAllLinesAndDots();
                    // 所有元素短暂放大，表示CDN的整体优势
                    [userEl, originEl, cdn1El, cdn2El, cdn3El].forEach(el => {
                        el.style.transform = 'scale(1.05)';
                        setTimeout(() => el.style.transform = 'scale(1)', 500);
                    });
                    return Promise.resolve();
                }
            }
        ];

        /**
         * 推进到下一个动画步骤
         */
        async function nextStep() {
            // 清除任何可能正在进行的单个动画计时器
            if (animationTimeout) {
                clearTimeout(animationTimeout);
                animationTimeout = null;
            }

            // 清除当前屏幕上所有的线条和圆点动画效果
            hideAllLinesAndDots();

            currentStep = (currentStep + 1);
            if (currentStep >= steps.length) {
                 currentStep = 0; // 循环回到第一个步骤
            }
            descriptionEl.innerHTML = steps[currentStep].description; // 更新步骤描述
            await steps[currentStep].action(); // 执行当前步骤的动画，等待其完成
            return Promise.resolve();
        }

        /**
         * 重置动画到初始状态
         */
        function resetAnimation() {
            currentStep = 0; // 回到第一步
            // 如果自动播放正在进行，则停止它
            if (autoPlayInterval) {
                clearTimeout(autoPlayInterval);
                autoPlayInterval = null;
                autoPlayBtn.classList.remove('hidden');
                pauseAutoPlayBtn.classList.add('hidden');
            }
            // 清除所有动画和元素状态
            hideAllLinesAndDots();

            // 将元素重置为初始步骤（步骤0）的状态
            userEl.classList.remove('hidden');
            originEl.classList.remove('hidden');
            cdn1El.classList.add('hidden');
            cdn2El.classList.add('hidden');
            cdn3El.classList.add('hidden');
            descriptionEl.innerHTML = steps[0].description; // 显示第一步描述
        }

        /**
         * 开始自动播放动画
         */
        async function startAutoPlay() {
            if (autoPlayInterval) return; // 如果已经在自动播放，则不执行

            autoPlayBtn.classList.add('hidden');
            pauseAutoPlayBtn.classList.remove('hidden');

            const playLoop = async () => {
                await nextStep(); // 执行下一个步骤并等待其动画完成
                // 在当前步骤动画完成后，设置延迟以开始下一个步骤
                autoPlayInterval = setTimeout(playLoop, 5000); // 每5秒切换一次步骤
            };
            await playLoop(); // 立即开始第一轮自动播放
        }

        /**
         * 暂停自动播放动画
         */
        function pauseAutoPlay() {
            if (autoPlayInterval) {
                clearTimeout(autoPlayInterval); // 清除下一个步骤的计时器
                autoPlayInterval = null;
            }
            autoPlayBtn.classList.remove('hidden');
            pauseAutoPlayBtn.classList.add('hidden');
        }

        // 绑定按钮事件监听器
        nextBtn.addEventListener('click', nextStep);
        resetBtn.addEventListener('click', resetAnimation);
        autoPlayBtn.addEventListener('click', startAutoPlay);
        pauseAutoPlayBtn.addEventListener('click', pauseAutoPlay);

        // 页面加载完成后执行初始化
        window.onload = () => {
            resetAnimation(); // 重置到初始状态并显示第一步描述
        };

        // 窗口大小调整时，重新绘制可见线条的位置，以适应新的布局
        window.addEventListener('resize', () => {
            document.querySelectorAll('.line').forEach(lineEl => {
                // 如果线条是可见的，则重新计算并绘制其路径
                if (lineEl.style.display !== 'none' && lineEl.style.opacity !== '0') {
                    const idParts = lineEl.id.split('-');
                    // 根据ID解析出起始和结束元素的ID
                    const startElId = idParts[1];
                    const endElId = idParts[2];
                    const startEl = document.getElementById(startElId);
                    const endEl = document.getElementById(endElId);
                    if (startEl && endEl) {
                       drawLinePath(lineEl, startEl, endEl);
                    }
                }
            });
        });
    </script>
</body>
</html>
